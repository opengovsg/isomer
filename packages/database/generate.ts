import * as fs from 'fs/promises'
import * as path from 'path'
import ts, { createSourceFile } from 'typescript'

const TYPE_FOLDER = './types'
// THIS MUST BE PREFIXED WITH A DOT
const TYPE_FILE = './generatedTypes.ts'
const GENERATED_FILE = './selectableTypes.ts'

const KYSELY_IMPORT = ts.factory.createImportDeclaration(
  undefined,
  ts.factory.createImportClause(
    false,
    undefined,
    ts.factory.createNamedImports([
      ts.factory.createImportSpecifier(
        true,
        undefined,
        ts.factory.createIdentifier('Selectable'),
      ),
    ]),
  ),
  ts.factory.createStringLiteral('kysely'),
)

const GENERATED_IMPORT = ts.factory.createImportDeclaration(
  undefined,
  ts.factory.createImportClause(
    true,
    undefined,
    ts.factory.createNamespaceImport(ts.factory.createIdentifier('T')),
  ),
  ts.factory.createStringLiteral(TYPE_FILE.replace(/\.ts$/, '')),
)

const HEADER = [
  ts.addSyntheticLeadingComment(
    KYSELY_IMPORT,
    ts.SyntaxKind.SingleLineCommentTrivia,
    'THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY.',
    true,
  ),
  GENERATED_IMPORT,
]

const extractTableTypes = (source: ts.SourceFile) => {
  const database = source.statements.find((statement) => {
    if (statement.kind !== ts.SyntaxKind.TypeAliasDeclaration) {
      return false
    }
    const declaration = statement as ts.TypeAliasDeclaration
    const identifier = declaration.name
    if (identifier.text === 'DB') {
      return true
    }
    return false
  }) as ts.TypeAliasDeclaration | undefined

  if (!database) {
    throw new Error()
  }

  const { type } = database

  if (type.kind !== ts.SyntaxKind.TypeLiteral) {
    throw new Error()
  }

  const schema = (type as ts.TypeLiteralNode).members

  const tables: string[] = []

  for (const entry of schema) {
    if (entry.kind !== ts.SyntaxKind.PropertySignature) {
      continue
    }
    const property = entry as ts.PropertySignature
    const { type } = property
    if (!type || type.kind !== ts.SyntaxKind.TypeReference) {
      continue
    }
    const reference = type as ts.TypeReferenceNode
    const identifier = reference.typeName as ts.Identifier
    tables.push(identifier.getText(source))
  }
  return tables
}

export const generate = async () => {
  const file = await fs.readFile(path.join(__dirname, TYPE_FOLDER, TYPE_FILE))
  const source = createSourceFile(
    TYPE_FILE,
    file.toString(),
    ts.ScriptTarget.ES2015,
  )

  const tableTypes = extractTableTypes(source)

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })

  const statements: ts.Statement[] = [...HEADER]

  for (const tableType of tableTypes) {
    statements.push(
      ts.factory.createTypeAliasDeclaration(
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        ts.factory.createIdentifier(tableType),
        undefined,
        ts.factory.createTypeReferenceNode(
          ts.factory.createIdentifier('Selectable'),
          [
            ts.factory.createTypeReferenceNode(
              ts.factory.createQualifiedName(
                ts.factory.createIdentifier('T'),
                ts.factory.createIdentifier(tableType),
              ),
              undefined,
            ),
          ],
        ),
      ),
    )
  }

  const target = ts.factory.createSourceFile(
    statements,
    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
    ts.NodeFlags.None,
  )

  const output_file = path.join(__dirname, TYPE_FOLDER, GENERATED_FILE)

  await fs.writeFile(output_file, printer.printFile(target))
}

generate().catch((error) => console.log(error))
