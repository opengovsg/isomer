import { scryptSync, timingSafeEqual } from "node:crypto"
import { NextApiRequest } from "next"
import { customAlphabet } from "nanoid"

import {
  OTP_ALPHABET,
  OTP_LENGTH,
  OTP_PREFIX_ALPHABET,
  OTP_PREFIX_LENGTH,
} from "~/lib/auth"
import { normaliseEmail } from "~/utils/zod"

export const createVfnToken = customAlphabet(OTP_ALPHABET, OTP_LENGTH)

export const createVfnPrefix = customAlphabet(
  OTP_PREFIX_ALPHABET,
  OTP_PREFIX_LENGTH,
)

export const createTokenHash = (token: string, email: string) => {
  return scryptSync(token, email, 64).toString("base64")
}

export const compareHash = (token: string, email: string, hash: string) => {
  return timingSafeEqual(
    Buffer.from(hash),
    Buffer.from(createTokenHash(token, email)),
  )
}

/**
 * Returns a provider ID for an account that is tied to a specific POCDEX email from sgID.
 * It will serve as a unique identifier for the specific POCDEX account, as a single sgID provider can return multiple POCDEX emails.
 * @param sgidSub The sgID sub returned from sgID
 * @param pocdexEmail The POCDEX email to tie the account to
 */
export const createPocdexAccountProviderId = (
  sgidSub: string,
  pocdexEmail: string,
) => {
  return `${sgidSub}-${normaliseEmail.parse(pocdexEmail)}`
}

export const extractOriginIp = (req: NextApiRequest) => {
  const cloudflareIp = req.headers["cf-connecting-ip"]
  if (cloudflareIp) {
    // NOTE: this is a header generated by Cloudflare
    // on the client ip address that connected to the cf reverse proxy
    // so this is guaranteed to be a string if it exists
    // see: https://developers.cloudflare.com/fundamentals/reference/http-request-headers/#cf-connecting-ip
    return cloudflareIp as string
  }

  // NOTE: If the client closes the socket prior to the request being serviced
  // the value may be `undefined`.
  // In this case, we will just assign this a default value for graceful handling
  return req.socket.remoteAddress ?? "localhost"
}
